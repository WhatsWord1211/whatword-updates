rules_version = '2';
service cloud.firestore {
  // Helper functions
  function isPvpParticipant(game, uid) {
    return (
      (game.data.players != null && uid in game.data.players) ||
      (game.data.playerIds != null && uid in game.data.playerIds) ||
      (game.data.player1 != null && game.data.player1.uid == uid) ||
      (game.data.player2 != null && game.data.player2.uid == uid)
    );
  }

  function isGameBetween(gameId, uidA, uidB) {
    let game = get(/databases/$(database)/documents/games/$(gameId));
    return (
      // PvP games: both users must be participants
      (game.data.type == 'pvp' && isPvpParticipant(game, uidA) && isPvpParticipant(game, uidB)) ||
      // Solo games: owner is uidA or uidB
      (game.data.type == 'solo' && (game.data.userId == uidA || game.data.userId == uidB))
    );
  }

  match /databases/{database}/documents {
    // User profiles - owner has full access, others can read for friend system
    match /users/{userId} {
      // Owner has full access to their profile
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Other authenticated users can read user data for friend system and leaderboards
      allow read: if request.auth != null;

      // Allow participants to add/remove game IDs in another user's activeGames list
      // Only activeGames can be changed; allow adding the first entry as well
      allow update: if request.auth != null &&
        request.auth.uid != userId &&
        request.resource.data.keys().hasOnly(['activeGames']) &&
        request.resource.data.activeGames is list &&
        // If the field previously existed, enforce per-game relationship
        (
          (resource.data.activeGames is list &&
            request.resource.data.activeGames.every(gid => (gid in resource.data.activeGames) || isGameBetween(gid, request.auth.uid, userId)) &&
            resource.data.activeGames.every(gid => (gid in request.resource.data.activeGames) || isGameBetween(gid, request.auth.uid, userId))
          ) ||
          // If the field didn't exist before, allow creation with games involving both users
          (!(resource.data.activeGames is list) &&
            request.resource.data.activeGames.size() > 0 &&
            request.resource.data.activeGames.every(gid => isGameBetween(gid, request.auth.uid, userId))
          )
        );
    }
    
    // Games - only participants can access
    match /games/{gameId} {
      // Allow read for existing games (handle both field naming conventions)
      allow read: if request.auth != null && 
        (resource.data.type == 'solo' && resource.data.userId == request.auth.uid) ||
        (resource.data.type == 'pvp' && 
         ((resource.data.players != null && request.auth.uid in resource.data.players) || 
          (resource.data.playerIds != null && request.auth.uid in resource.data.playerIds) ||
          (resource.data.player1 != null && resource.data.player1.uid == request.auth.uid) ||
          (resource.data.player2 != null && resource.data.player2.uid == request.auth.uid)));
      
      // Allow create for new games (handle both field naming conventions)
      allow create: if request.auth != null && 
        (request.resource.data.type == 'solo' && request.resource.data.userId == request.auth.uid) ||
        (request.resource.data.type == 'pvp' && 
         ((request.resource.data.players != null && request.auth.uid in request.resource.data.players) || 
          (request.resource.data.playerIds != null && request.auth.uid in request.resource.data.playerIds) ||
          (request.resource.data.player1 != null && request.resource.data.player1.uid == request.auth.uid) ||
          (request.resource.data.player2 != null && request.resource.data.player2.uid == request.auth.uid)));
      
      // Allow update/delete for existing games (handle both field naming conventions)
      allow update, delete: if request.auth != null && 
        (resource.data.type == 'solo' && resource.data.userId == request.auth.uid) ||
        (resource.data.type == 'pvp' && 
         ((resource.data.players != null && request.auth.uid in resource.data.players) || 
          (resource.data.playerIds != null && request.auth.uid in resource.data.playerIds) ||
          (resource.data.player1 != null && resource.data.player1.uid == request.auth.uid) ||
          (resource.data.player2 != null && resource.data.player2.uid == request.auth.uid)));
    }
    
    // PvP games - only participants can access
    match /pvpGames/{gameId} {
      // Allow read for existing games
      allow read: if request.auth != null && 
        request.auth.uid in resource.data.players;
      
      // Allow create for new games
      allow create: if request.auth != null && 
        request.auth.uid in request.resource.data.players;
      
      // Allow update/delete for existing games
      allow update, delete: if request.auth != null && 
        request.auth.uid in resource.data.players;
    }
    
    // Challenges - only the sender and recipient can access
    match /challenges/{challengeId} {
      // Allow read for existing challenges (handle both field naming conventions)
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid ||
         request.auth.uid == resource.data.from || 
         request.auth.uid == resource.data.to);
      
      // Allow create for new challenges (handle both field naming conventions)
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.fromUid || 
         request.auth.uid == request.resource.data.toUid ||
         request.auth.uid == request.resource.data.from || 
         request.auth.uid == request.resource.data.to);
      
      // Allow update/delete for existing challenges (handle both field naming conventions)
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid ||
         request.auth.uid == resource.data.from || 
         request.auth.uid == resource.data.to);
    }
    
    // Game statistics - users can read for leaderboards, but only modify their own
    match /gameStats/{gameStatId} {
      // Anyone authenticated can read game stats for leaderboard functionality
      allow read: if request.auth != null;

      // Participants of the game can create or update the stats document
      allow create, update: if request.auth != null &&
        request.resource.data.type == 'pvp' &&
        request.resource.data.players is list &&
        request.auth.uid in request.resource.data.players;

      // Participants can delete stats (rarely used; retain symmetry)
      allow delete: if request.auth != null &&
        resource.data.type == 'pvp' &&
        resource.data.players is list &&
        request.auth.uid in resource.data.players;
    }
    
    // Friend requests - only the sender and recipient can access
    match /friendRequests/{requestId} {
      // Allow read for existing friend requests (handle both field naming conventions)
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid ||
         request.auth.uid == resource.data.from || 
         request.auth.uid == resource.data.to);
      
      // Allow create for new friend requests (handle both field naming conventions)
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.fromUid || 
         request.auth.uid == request.resource.data.toUid ||
         request.auth.uid == request.resource.data.from || 
         request.auth.uid == request.resource.data.to);
      
      // Allow update/delete for existing friend requests (handle both field naming conventions)
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid ||
         request.auth.uid == resource.data.from || 
         request.auth.uid == resource.data.to);
    }
    
    // Notifications - only the recipient can access
    match /notifications/{notificationId} {
      // Allow read for existing notifications (handle both field naming conventions)
      allow read: if request.auth != null && 
        (resource.data.to == request.auth.uid || resource.data.toUid == request.auth.uid);
      
      // Allow create for new notifications (anyone can create notifications for others)
      allow create: if request.auth != null;
      
      // Allow update/delete for existing notifications (handle both field naming conventions)
      allow update, delete: if request.auth != null && 
        (resource.data.to == request.auth.uid || resource.data.toUid == request.auth.uid);
    }
    
    // Leaderboard - anyone can read, users can only modify their own scores
    match /leaderboard/{scoreId} {
      // Anyone can read leaderboard data
      allow read: if request.auth != null;
      
      // Users can only create/update their own scores
      allow create, update: if request.auth != null && 
        (scoreId.matches('score_.*') && 
         request.resource.data.userId == request.auth.uid);
      
      // Users can only delete their own scores
      allow delete: if request.auth != null && 
        (scoreId.matches('score_.*') && 
         resource.data.userId == request.auth.uid);
    }
    
    // Game invites - only the sender and recipient can access
    match /gameInvites/{inviteId} {
      // Allow read for existing game invites (handle both field naming conventions)
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid ||
         request.auth.uid == resource.data.from || 
         request.auth.uid == resource.data.to);
      
      // Allow create for new game invites (handle both field naming conventions)
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.fromUid || 
         request.auth.uid == request.resource.data.toUid ||
         request.auth.uid == request.resource.data.from || 
         request.auth.uid == request.resource.data.to);
      
      // Allow update/delete for existing game invites (handle both field naming conventions)
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid ||
         request.auth.uid == resource.data.from || 
         request.auth.uid == resource.data.to);
    }
    
    // Word lists - anyone can read (these are public game data)
    match /words/{wordId} {
      allow read: if request.auth != null;
      // No write access needed for word lists
    }
    
    // User achievements - only the owner can access
    match /achievements/{achievementId} {
      allow read, write: if request.auth != null && 
        resource.data.userId == request.auth.uid;
    }
    
    // User badges - only the owner can access
    match /badges/{badgeId} {
      allow read, write: if request.auth != null && 
        resource.data.userId == request.auth.uid;
    }
    
    // User settings - only the owner can access
    match /userSettings/{settingId} {
      allow read, write: if request.auth != null && 
        settingId == request.auth.uid;
    }
    
    // Privacy settings - only the owner can access
    match /privacySettings/{settingId} {
      allow read, write: if request.auth != null && 
        settingId == request.auth.uid;
    }
    
    // User subcollections - friends
    match /users/{userId}/friends/{friendId} {
      // Either party in the friendship can read the record
      allow read: if request.auth != null && (request.auth.uid == userId || request.auth.uid == friendId);

      // Sender (friendId) can create a pending request in recipient's subcollection
      allow create: if request.auth != null &&
        request.auth.uid == friendId &&
        request.resource.data.status in ['pending', 'accepted', 'declined'] &&
        // For initial request from sender, ensure senderId matches caller when present
        (!('senderId' in request.resource.data) || request.resource.data.senderId == request.auth.uid);

      // Updates:
      // - Recipient (owner userId) can accept/decline a pending request on their doc
      // - Owner can also mark a friend as blocked on their own doc
      allow update: if request.auth != null && (
        (
          request.auth.uid == userId &&
          (
            (resource.data.status == 'pending' && request.resource.data.status in ['accepted', 'declined']) ||
            (request.resource.data.status == 'blocked')
          )
        ) ||
        // On accept, the recipient may mirror a doc into sender's subcollection
        (
          request.auth.uid == friendId &&
          request.resource.data.status in ['accepted'] &&
          // When mirroring, ensure the friendId field (if present) matches caller
          (!('friendId' in request.resource.data) || request.resource.data.friendId == request.auth.uid)
        )
      );

      // Either party can delete their copy of the relationship document
      allow delete: if request.auth != null && (request.auth.uid == userId || request.auth.uid == friendId);
    }
    
    // User subcollections - challenges
    match /users/{userId}/challenges/{challengeId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId;
    }
  }
}
