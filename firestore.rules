rules_version = '2';
service cloud.firestore {
  // Helper functions
  function isTester() {
    return request.auth != null &&
      (request.auth.uid == 'JiRbXc8grSMPdQwjn1S990qekVG2' ||
       request.auth.uid == 'WV1DoVtAjdckYqOLHphqUgsMIXX2' ||
       request.auth.uid == 'MBtE3XyYCwaPMljmmPpZnineRsG3');
  }

  function isPvpParticipant(game, uid) {
    return (
      (game.data.players != null && uid in game.data.players) ||
      (game.data.playerIds != null && uid in game.data.playerIds) ||
      (game.data.player1 != null && game.data.player1.uid == uid) ||
      (game.data.player2 != null && game.data.player2.uid == uid)
    );
  }

  function isGameBetween(gameId, uidA, uidB) {
    let game = get(/databases/$(database)/documents/games/$(gameId));
    return (
      // PvP games: both users must be participants
      (game.data.type == 'pvp' && isPvpParticipant(game, uidA) && isPvpParticipant(game, uidB)) ||
      // Solo games: owner is uidA or uidB
      (game.data.type == 'solo' && (game.data.userId == uidA || game.data.userId == uidB))
    );
  }

  match /databases/{database}/documents {
    // Global override for tester accounts: full read/write during review
    allow read, write: if isTester();

    // User profiles - owner has full access, others can read for friend system
    match /users/{userId} {
      // Owner has full access to their profile (this should allow all updates)
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Other authenticated users can read user data for friend system and leaderboards
      allow read: if request.auth != null;

      // Allow cross-user updates for specific fields only
      allow update: if request.auth != null &&
        request.auth.uid != userId &&
        // Allow updates to friends field (for friend management)
        (resource.data.diff(request.resource.data).changedKeys().hasOnly(['friends']) ||
         // Allow updates to activeGames field (for game tracking)
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['activeGames']) ||
         // Allow updates to game statistics fields (solo mode)
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['easyAverageScore', 'regularAverageScore', 'hardAverageScore']) ||
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['easyGamesCount', 'regularGamesCount', 'hardGamesCount']) ||
         // Allow updates to PvP statistics fields
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['pvpGamesPlayed', 'pvpGamesWon', 'pvpWinRate']) ||
         // Allow updates to general game statistics
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['gamesPlayed', 'gamesWon', 'bestScore']) ||
         // Allow updates to multiple game stats fields together (from updateGameStats)
         (resource.data.diff(request.resource.data).changedKeys().hasAll(['gamesPlayed', 'lastGamePlayed']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['gamesPlayed', 'totalScore', 'averageScore']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['gamesPlayed', 'gamesWon', 'currentStreak']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['gamesPlayed', 'hintsUsed', 'gamesWithHints']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['gamesPlayed', 'gamesWithoutHints']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['bestScore'])) ||
         // Allow updates to total score
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['totalScore']) ||
         // Allow updates to rank-related fields
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['previousRank']) ||
         // Allow updates to achievements field
         resource.data.diff(request.resource.data).changedKeys().hasOnly(['achievements']) ||
         // Allow multiple related fields together
         resource.data.diff(request.resource.data).changedKeys().hasAll(['friends', 'lastUpdated']) ||
         resource.data.diff(request.resource.data).changedKeys().hasAll(['activeGames', 'lastUpdated']) ||
         // Allow multiple stats fields to be updated together
         (resource.data.diff(request.resource.data).changedKeys().hasAll(['easyAverageScore', 'easyGamesCount', 'lastUpdated']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['regularAverageScore', 'regularGamesCount', 'lastUpdated']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['hardAverageScore', 'hardGamesCount', 'lastUpdated']) ||
          // Allow just the average and count without lastUpdated
          resource.data.diff(request.resource.data).changedKeys().hasAll(['easyAverageScore', 'easyGamesCount']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['regularAverageScore', 'regularGamesCount']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['hardAverageScore', 'hardGamesCount']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['pvpGamesPlayed', 'pvpGamesWon', 'pvpWinRate']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['gamesPlayed', 'gamesWon', 'totalScore']) ||
          resource.data.diff(request.resource.data).changedKeys().hasAll(['lastUpdated'])) ||
         // Allow push token fields (but only from the device owner)
         (resource.data.diff(request.resource.data).changedKeys().hasOnly(['expoPushToken', 'pushTokenUpdatedAt', 'pushNotificationsEnabled']) &&
          request.auth.uid == userId) ||
         (resource.data.diff(request.resource.data).changedKeys().hasOnly(['pushToken', 'pushTokenUpdatedAt', 'pushNotificationsEnabled']) &&
          request.auth.uid == userId));
    }
    
    // Games - only participants can access
    match /games/{gameId} {
      // Allow read for existing games (handle both field naming conventions)
      allow read: if request.auth != null && 
        (resource.data.type == 'solo' && resource.data.userId == request.auth.uid) ||
        (resource.data.type == 'pvp' && 
         ((resource.data.players != null && request.auth.uid in resource.data.players) || 
          (resource.data.playerIds != null && request.auth.uid in resource.data.playerIds) ||
          (resource.data.player1 != null && resource.data.player1.uid == request.auth.uid) ||
          (resource.data.player2 != null && resource.data.player2.uid == request.auth.uid)));
      
      // Allow create for new games (handle both field naming conventions)
      allow create: if request.auth != null && 
        (request.resource.data.type == 'solo' && request.resource.data.userId == request.auth.uid) ||
        (request.resource.data.type == 'pvp' && 
         ((request.resource.data.players != null && request.auth.uid in request.resource.data.players) || 
          (request.resource.data.playerIds != null && request.auth.uid in request.resource.data.playerIds) ||
          (request.resource.data.player1 != null && request.resource.data.player1.uid == request.auth.uid) ||
          (request.resource.data.player2 != null && request.resource.data.player2.uid == request.auth.uid)));
      
      // Allow update/delete for existing games (TEMPORARILY PERMISSIVE FOR TESTING)
      allow update, delete: if request.auth != null;
    }
    
    // PvP games - only participants can access
    match /pvpGames/{gameId} {
      // Allow read for existing games
      allow read: if request.auth != null && 
        request.auth.uid in resource.data.players;
      
      // Allow create for new games
      allow create: if request.auth != null && 
        request.auth.uid in request.resource.data.players;
      
      // Allow update/delete for existing games
      allow update, delete: if request.auth != null && 
        request.auth.uid in resource.data.players;
    }
    
    // Challenges - only the sender and recipient can access
    match /challenges/{challengeId} {
      // Allow read for existing challenges (using correct field names)
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid);
      
      // Allow create for new challenges (using correct field names)
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.fromUid || 
         request.auth.uid == request.resource.data.toUid);
      
      // Allow update/delete for existing challenges (using correct field names)
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid);
    }
    
    // Game statistics - users can read for leaderboards, but only modify their own
    match /gameStats/{gameStatId} {
      // Anyone authenticated can read game stats for leaderboard functionality
      allow read: if request.auth != null;

      // Participants of the game can create or update the stats document
      allow create, update: if request.auth != null &&
        request.resource.data.type == 'pvp' &&
        request.resource.data.players is list &&
        request.auth.uid in request.resource.data.players;

      // Participants can delete stats (rarely used; retain symmetry)
      allow delete: if request.auth != null &&
        resource.data.type == 'pvp' &&
        resource.data.players is list &&
        request.auth.uid in resource.data.players;
    }
    
    // Friend requests - only the sender and recipient can access
    match /friendRequests/{requestId} {
      // Allow read for existing friend requests (using correct field names)
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid);
      
      // Allow create for new friend requests (using correct field names)
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.fromUid || 
         request.auth.uid == request.resource.data.toUid);
      
      // Allow update/delete for existing friend requests (using correct field names)
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid);
    }
    
    // Notifications - enhanced security
    match /notifications/{notificationId} {
      // Allow read for existing notifications (using correct field names)
      allow read: if request.auth != null && 
        (resource.data.toUid == request.auth.uid);
      
      // Enhanced create rule - prevent spam
      allow create: if request.auth != null &&
        request.resource.data.toUid != null &&
        (request.resource.data.fromUid == request.auth.uid ||
         // Allow system notifications (from push notification service)
         request.resource.data.fromUid == 'system' ||
         // Allow game-related notifications from participants
         (request.resource.data.type in ['game_challenge', 'game_started', 'game_completed', 'game_move'] &&
          request.resource.data.participants is list &&
          request.auth.uid in request.resource.data.participants) ||
         // Allow notifications where the current user is involved (sender or recipient)
         (request.resource.data.fromUid == request.auth.uid || request.resource.data.toUid == request.auth.uid));
      
      // Allow update/delete for existing notifications (using correct field names)
      allow update, delete: if request.auth != null && 
        (resource.data.toUid == request.auth.uid);
    }
    
    // Leaderboard - enhanced validation
    match /leaderboard/{scoreId} {
      // Anyone can read leaderboard data
      allow read: if request.auth != null;
      
      // Enhanced create/update rule - validate required fields
      allow create, update: if request.auth != null && 
        (scoreId.matches('score_.*') && 
         request.resource.data.userId == request.auth.uid &&
         request.resource.data.keys().hasAll(['userId', 'score', 'timestamp']));
      
      // Users can only delete their own scores
      allow delete: if request.auth != null && 
        (scoreId.matches('score_.*') && 
         resource.data.userId == request.auth.uid);
    }
    
    // Game invites - only the sender and recipient can access
    match /gameInvites/{inviteId} {
      // Allow read for existing game invites (using correct field names)
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid);
      
      // Allow create for new game invites (using correct field names)
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.fromUid || 
         request.auth.uid == request.resource.data.toUid);
      
      // Allow update/delete for existing game invites (using correct field names)
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.fromUid || 
         request.auth.uid == resource.data.toUid);
    }
    
    // Word lists - anyone can read (these are public game data)
    match /words/{wordId} {
      allow read: if request.auth != null;
      // No write access needed for word lists
    }
    
    // User achievements - only the owner can access
    match /achievements/{achievementId} {
      allow read, write: if request.auth != null && 
        resource.data.userId == request.auth.uid;
    }
    
    // User badges - only the owner can access
    match /badges/{badgeId} {
      allow read, write: if request.auth != null && 
        resource.data.userId == request.auth.uid;
    }
    
    // User settings - only the owner can access
    match /userSettings/{settingId} {
      allow read, write: if request.auth != null && 
        settingId == request.auth.uid;
    }
    
    // Privacy settings - only the owner can access
    match /privacySettings/{settingId} {
      allow read, write: if request.auth != null && 
        settingId == request.auth.uid;
    }
    
    // User subcollections - friends
    match /users/{userId}/friends/{friendId} {
      // Either party in the friendship can read the record
      allow read: if request.auth != null && (request.auth.uid == userId || request.auth.uid == friendId);

      // Sender (friendId) can create a pending request in recipient's subcollection
      allow create: if request.auth != null &&
        request.auth.uid == friendId &&
        request.resource.data.status in ['pending', 'accepted', 'declined'] &&
        // For initial request from sender, ensure senderId matches caller when present
        (!('senderId' in request.resource.data) || request.resource.data.senderId == request.auth.uid);

      // Updates:
      // - Recipient (owner userId) can accept/decline a pending request on their doc
      // - Owner can also mark a friend as blocked on their own doc
      allow update: if request.auth != null && (
        (
          request.auth.uid == userId &&
          (
            (resource.data.status == 'pending' && request.resource.data.status in ['accepted', 'declined']) ||
            (request.resource.data.status == 'blocked')
          )
        ) ||
        // On accept, the recipient may mirror a doc into sender's subcollection
        (
          request.auth.uid == friendId &&
          request.resource.data.status in ['accepted'] &&
          // When mirroring, ensure the friendId field (if present) matches caller
          (!('friendId' in request.resource.data) || request.resource.data.friendId == request.auth.uid)
        )
      );

      // Either party can delete their copy of the relationship document
      allow delete: if request.auth != null && (request.auth.uid == userId || request.auth.uid == friendId);
    }
    
    // User subcollections - challenges
    match /users/{userId}/challenges/{challengeId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId;
    }
  }
}